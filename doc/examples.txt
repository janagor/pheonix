// These are one line comments.

/*
these
are
multiline
comments
*/

// There is no way of including other files.

// The primitive types in the language are: u8, u16, u32, u64, i8, i16, i32, i64, bool.

// Type has to be always written explicitly
let global a: u32 = 12;
// let global d = 12; error: the type of variable has to be written explicitly

// global variables need to be initiated with "global" keyword

let global a: u32 = 12;
// let d: u32 = 12; error: no use of "global" keyword

// Variables are constant by default. To make them mutable you need to use
// "mut" keyword at initiation.
// "global mut" or "mut global" are both available.
let global mut b: u16 = 1;
let mut global c: u16 = 1;

// Everything is passed via value/copy, so for objects there is always a copy created
// no moving

// You can declare global functions. They are visible from any part of the code.
// Currently private functions are not supported.
fn example_function() {
    /* ... */
}

// Function can take 0, 1, or more parameters ...
fn function_with_parameters(param1: u16, param2: i8) {
    /* ... */
}

// ... and can return a value or not.
fn function_with_return_value() -> u32 {
    let x: u32 = 1;
    return x;
}

fn function_without_return_value() {
    /* ... */
}
// Function without return value can but does not need to have "return"
// keyword.
fn function_without_return_value_with_keyword() {
    /* ... */
    return;
}

// Parameters of the function cannot be changes unless they are "mutable"
fn change(param1: mut u16, param2: u16) {
    param1 = 12; // ok
    // param2 = 12; // 'error[54: 5]: unmutable function parameter
                    // "param2: u16" cannot be changed. You can use
                    //  "let param2: u16 = 12;" to "shadow" it.'
    /* ... */
}

// You can create structs.
struct Empty {}

// Struct can have parameters of an explicit type
struct Person {
    age: u8,
    weight: u8,
    height: u8,
}

// Those parameters are unmutable after initiation unless you use "mut" keyword
// with a given field
struct Person {
    age : mut u8,
    weight: u8,
    height: u8,
}

// They can also have methods.
struct DancingPerson {
    age: u8,
    weight: u8,
    height: u8,
    fn dance() {},
}

// Methods can change fields of structures only if those fields are mutable
struct DancingPerson {
    isSmiling: bool,
    isDancing: mut bool,
    fn dance(dancing: bool) {
        isDancing = d; // ok
    },
    fn smile(smiling: bool) {
        // isSmiling = smiling; // 'error[95: 9]: unmutable struct field
                                // "isSmiling: bool" is not mutable.'
    },
}

// There are additon, subtraction, multiplication and devision operations.
fn example_of_math_operations() {
    // Factors in expressions must be of the same type. 
    let a: u32 = 1;
    let b: u16 = 2;
    // a+b; // 'error[106: 5]: expression "a+b" cannot be evaluated. "a: u32"
            // and "b: u16" have different types.'
    let b: u32 = 2;
    a+b; // ok
    a-b; // ok
    a*b; // ok
    a/b; // ok

    // Result type of those operation is the same as type of the r-value
    // expression.
    // let c: u16 = a+b; // 'error[113: 5]: expected type "u16", found "u32".'
    let c: u32 = a+b; // ok.

    // To cast variable of one type into another you can use "as" operator.
    let a: u32 = 1;
    // let b: u16 = a; // 'error[120: 5]: expected type "u16", found "u32".'
    let b: u16 = a as u16; // ok
    let c: u16 = a as u16 + a as u16; // ok.

    // Such cast can be unsafe when range of 'from' type is smaller than 'into'
    // type. The cast will occure as in C: only only the lower bits will be
    // stored.
    let a: i8 = -1;
    let b: u8 = e as u8; // f = 255;

    // TODO: no float type currently in mind.
}

fn add(a: u32, b: u32) -> u32 {
    return a + b;
}

// There is an "|>" operator, which works similar to shell "|" operator. It
// passes result of its left-hand expression into a place(s) at it's
// right-hand side..
fn pipe_like_operation() {
    let a: u32 = 1;
    let b: u32 = 2;
    let c: u32 = b |> add(@, a); // 3, same as add(b, a)

    // It is evaluated from left to right.
    let c: u32 = b |> add(@, a) |> add(@, a); // 4, same as add(add(b, a), a)
    let d: u32 = ( b |> add(@, a) ) |> add(@, a); // 4, same as in the line
    // above.
}

///////////////////////////////////////////////////////////////////////////////
// TODO: Can structure be created in the function? same as function in function
// and structure in structure etc..

struct Rectangle {
    width: u32,
    height: u32,

    fn get_area() -> u32 {
        return width * height;
    }
    fn get_perimeter() -> u32 {
        let result = 2 * (width * height);
        return result;
    }
}

fn operate_on_rectangle(rec: Rectangle) {
    let area: u32 = rec.get_area();
    let perimeter: u32 = rec.get_perimeter();
}

struct Circle {
    radius: u32,
    x_cord: i32,
    y_cord: i32,
}

fn new_radius_of_circle(c: mut Circle, r: u32) -> Circle {
    c.radius = r;
    return c;
}

fn new_circle() {
    let c: Circle = Circle {
        .radius = 1,
        . x_cord = -1,
        .
        y_cord = -1
    };
}
// no private fields and methods in structs
struct Big {
    value1: i32 = 0,
    value2: i32 = -1,
    fn () {
        let c: u32 = 12;
        let d: u32 = 13;
        let e: u32 = add(c, d);
        let f: u31 = d |> add(@, c) |> add(@, c);
        if (c == d) {
            let f: u32 = c; // start of lifetime of f
        } //  end of lifetime of f
    },

    fn add(first: u32, second: u32) -> u32 {
        return first + second;
    },
}

// main function is the starting point of the program.
// TODO: It currently does not have any parameters and does not return.
fn main () {
}

// TODO: document inheritance
struct Base {
    x: u32,
}

struct Derived inherits Base {
    y: u32,
}

fn test_inheritance() {
    let a: Base { .x = 12, };
    let b: Derived {
        .x = a.x,
        .y = 13,
    };
}

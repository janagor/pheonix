// These are one line comments.

/*
these
are
multiline
comments
*/

// There is no way of including other files.

// The primitive types in the language are: u8, u16, u32, u64, i8, i16, i32, i64, bool.

// Type has to be always written explicitly
let a: u32 = 12;
// let b = 12; error: the type of variable has to be written explicitly

// Variables are constant by default. To make them mutable you need to use
// "mut" keyword at initiation.
fn test_mutablity() {
    let mut b: u16 = 1;
    b = 12; // ok.
}

// Everything is passed via value/copy, so for objects there is always a copy created
// no moving

// You can declare global functions. They are visible from any part of the code.
// Currently private functions are not supported.
fn example_function() {
    /* ... */
}

// Function can take 0, 1, or more parameters ...
fn function_with_parameters(param1: u16, param2: i8) {
    /* ... */
};

// ... and can return a value or not.
fn function_with_return_value() -> u32 {
    let x: u32 = 1;
    return x;
}

fn function_without_return_value() {
    /* ... */
}
// Function without return value can but does not need to have "return"
// keyword.
fn function_without_return_value_with_keyword() {
    /* ... */
    return;
}

// Parameters of the function cannot be changes unless they are "mutable"
fn change(param1: mut u16, param2: u16) {
    param1 = 12; // ok.
    // param2 = 12; // 'error[54: 5]: unmutable function parameter
                    // "param2: u16" cannot be changed. You can use
                    //  "let param2: u16 = 12;" to "shadow" it.'
    /* ... */
}

// You can create structs.
struct Empty {}

// Creating an insance of a structure
let empty: Empty = Empty {};

// Struct can have parameters of an explicit type
struct Person {
    age: u8,
    weight: u8,
    height: u8,
}

// Creating an insance of a structure with parameters.
let person: Person = Person {
    .age = 18,
    .weight = 100,
    .height = 190,
};

// Structure instances can also be mutable or constant. By default they are
// constant Unless you use "mut" keyword AND while instantiating structure
// object you make it mutable with the keyword "mut" too.

struct Person {
    age : mut u8,
    weight: u8,
    height: u8,
}

let person: Person = Person {
    .age = 18,
    .weight = 100,
    .height = 190,
}; // all fields are constant
// person.age = 100; // 'error[97: 1]: cannot assign to an immutable object:
                     // "person".'

let person: mut Person = Person {
    .age = 18,
    .weight = 100,
    .height = 190,
}; // field 'age' is mutable
person.age = 100; // ok.

// They can also have methods.
struct DancingPerson {
    age: u8,
    weight: u8,
    height: u8,
    fn dance() {},
}

fn test_methods() {
    let person: DancingPerson = DancingPerson {
        .age = 18,
        .weight = 100,
        .height = 190,
    };

    person.dance();
}

// Methods can change fields of structures only if those fields are mutable
struct DancingPerson {
    isSmiling: bool,
    isDancing: mut bool,
    fn dance(dancing: bool) {
        isDancing = d; // ok.
    },
    fn smile(smiling: bool) {
        // isSmiling = smiling; // 'error[95: 9]: unmutable struct field
                                // "isSmiling: bool" is not mutable.'
    },
}

// Inheritance is allowed with "inherits" keyword. One struct can have only one
// Base clase from which it inherits.
struct Base {
    x: u32,
}

struct Derived inherits Base {
    y: u32,
}

fn test_inheritance() {
    let a: Base = Base { .x = 12, };
    let b: Derived = Derived {
        .x = a.x,
        .y = 13,
    };
}

// Shadowing is allowed.
struct Derived2 inherits Derived {
    x: i64,
}

fn test_shadowing_inheritance() {
    let a: i64 = 12;
    let b: Derived = Derived {
        .x = a, // ok.
        .y = 13,
    };
}

// There are additon, subtraction, multiplication and devision operations.
fn example_of_math_operations() {
    // Factors in expressions must be of the same type. 
    let a: u32 = 1;
    let b: u16 = 2;
    // a+b; // 'error[106: 5]: expression "a+b" cannot be evaluated. "a: u32"
            // and "b: u16" have different types.'
    let b: u32 = 2;
    a+b; // ok.
    a-b; // ok.
    a*b; // ok.
    a/b; // ok.

    // Result type of those operation is the same as type of the r-value
    // expression.
    // let c: u16 = a+b; // 'error[113: 5]: expected type "u16", found "u32".'
    let c: u32 = a+b; // ok.

    // To cast variable of one type into another you can use "as" operator.
    let a: u32 = 1;
    // let b: u16 = a; // 'error[120: 5]: expected type "u16", found "u32".'
    let b: u16 = a as u16; // ok.
    let c: u16 = a as u16 + a as u16; // ok.

    // Such cast can be unsafe when range of 'from' type is smaller than 'into'
    // type. The cast will occure as in C: only only the lower bits will be
    // stored.
    let a: i8 = -1;
    let b: u8 = e as u8; // f = 255;

    // TODO: no float type currently in mind.
}

fn add(a: u32, b: u32) -> u32 {
    return a + b;
}

// There is an "|>" operator, which works similar to shell "|" operator. It
// passes result of its left-hand expression into a place(s) at it's
// right-hand side..
fn pipe_like_operation() {
    let a: u32 = 1;
    let b: u32 = 2;
    let c: u32 = b |> add(@, a); // 3, same as add(b, a)

    // It is evaluated from left to right.
    let c: u32 = b |> add(@, a) |> add(@, a); // 4, same as add(add(b, a), a)
    let d: u32 = ( b |> add(@, a) ) |> add(@, a); // 4, same as in the line
    // above.
}

// Scopes can be created with "{}" signs.
fn scopes_example() {
    let a: u32 = 12; //
    {
        let a: u32 = 64;
        // a==64
    }
    // a==12
}

// Structure be created in the function. Same as function in function
// and structure in structure etc..
fn casted_structure() {
    struct Rectangle {
        width: u32,
        height: u32,

        fn get_area() -> u32 {
            return width * height;
        }
        fn get_perimeter() -> u32 {
            let result = 2 * (width * height);
            return result;
        }
    }

    let rectangle: Rectangle = {
        .width = 12,
        .height = 13,
    }; // ok
}

let wrong_rectangle: Rectangle = {
    .width = 12,
    .height = 13,
}; // 'error[194: 1]: cannot find "Rectangle" structure in the scope.'

// main function is the starting point of the program.
// NOTE: It currently does not have any parameters and does not return.
fn main () {
}

